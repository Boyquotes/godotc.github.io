>https://blog.csdn.net/qq_32974399/article/details/103956589#VBO_3
- VAO: vertex array obj
- VBO: vertex buffer obj
- IBO: index buffer obj

## VAO
>VAO的全名是Vertex Array Object，首先，它不是Buffer-Object，所以不用作存储数据；其次，它针对“顶点”而言，也就是说它跟“顶点的绘制”息息相关。（VAO和VA没有任何关系）
>VAO记录的是一次绘制中所需要的信息，这包括“数据在哪里glBindBuffer”、“数据的格式是怎么样的glVertexAttribPointer”、shader-attribute的location的启用glEnableVertexAttribArray。
  
记录一次绘制中需要的信息，包括：
-  数据在哪里( `glBindBuffer(GL_ARRAY_BUFFER)`)
-  数据的格式是什么( `glVertexAttribPointer(...)`)

保存vbo和attrib于它之内？
是的，用来启用一整个绘制的插槽



## VBO 
>VBO将顶点信息放到GPU中，GPU在渲染时去缓存中取数据，二者中间的桥梁是GL-Context。GL-Context整个程序一般只有一个，所以如果一个渲染流程里有两份不同的绘制代码，GL-context就负责在他们之间进行切换。这也是为什么要在渲染过程中，在每份绘制代码之中会有glBindbuffer、glEnableVertexAttribArray、glVertexAttribPointer。那么优化的方法来了，把这些都放到初始化时候完成吧！VAO记录该次绘制所需要的所有VBO所需信息，把它保存到VBO特定位置，绘制的时候直接在这个位置取信息绘制。

申请显卡上的一块内存空间
```cpp
GLuint vbo;
// 生成并 map Id
glGenbuffer(1,&vbo);
// 绑定当前状态机的ID， 指定buffer的类型为array
glBindBuffer(GL_ARRAY_BUFFER, vbo);
// 指定该id的储存大小并传输数据
glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_XXXX_DRAW);
```
